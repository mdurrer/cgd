<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The XOR Texture</title>
<meta content="text/html; charset=us-ascii" http-equiv=
"content-type" />
<link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<h1>Lode's Computer Graphics Tutorial</h1>
<h1>The XOR Texture<br /></h1>
<h2>Table of Contents</h2>
<ul>
<li><a href="#Introduction_">Introduction</a></li>
<li><a href="#The_XOR_Texture">The XOR Texture</a></li>
<li><a href="#Colors">Colors</a></li>
<li><a href="#AND_and_OR">AND and OR</a></li>
<li><a href="#Conclusion">Conclusion</a><br /></li>
</ul>
<a href="index.html">Back to index</a><br />
<h2><a name="Introduction_" id=
"Introduction_"></a>Introduction<br /></h2>
The XOR texture is a very easy to generate texture that looks fine.
However, it's so overused that it's not a good choice to use in in
a demo or intro release. It isn't useful for games either, unless
you want some fancy floor tiles. What it's useful for, is for
testing a texture mapper you just wrote, in case you want to
quickly test out a pattern without having to load an image file or
write more complex texture generation code.<br />
<br />
This is an extremely small article, but the XOR Texture just
couldn't be left out in a series of texture generation
articles.<br />
<h2><a name="The_XOR_Texture" id="The_XOR_Texture"></a>The XOR
Texture</h2>
The XOR texture is simply generated by xor-ing the x and y
coordinate of the current pixel. The '^' operator in C++ is the XOR
operator.<br />
<br />
<center>
<table class="codetable">
<tr>
<td style="vertical-align: top;">
<pre><span class="code">int main(int argc, char *argv[]) 
{ 
    screen(256, 256, 0, <span class=
"string">"The XOR Texture"</span>); 
   
    for(int x = 0; x &lt; w; x++) 
    for(int y = 0; y &lt; h; y++) 
    {    
         Uint8 c = x ^ y; 
         pset(x, y, ColorRGB(c, c, c)); 
    } 
   
    redraw(); 
    sleep(); 
    return 0; 
}</span></pre>
</td>
</tr>
</table>
</center>
<br />
That's it, if you run it, you see the XOR texture:<br />
<br />
<img alt="The XOR Texture" src="images/xortexture.gif" style=
"width: 255px; height: 255px;" /><br />
<br />
There are 3 things you should keep in mind though:<br />
<br />
<b>1)</b> The sizes of the texture should be a power of two, if
they aren't, the texture doesn't look as good:<br />
<br />
<img alt="" src="images/xortexturesize.gif" style=
"width: 184px; height: 169px;" /><br />
<br />
<b>2)</b> Color component values range from 0 to 255. The maximum
color value generated by the XOR operation is the same as the
dimensions of the texture if it's size is a power of two. So if the
size of your XOR pattern is smaller than 256, for example only 64,
it'll be too dark (image on the left). Multiply the color with 4 to
make it bright again (image on the right):<br />
<br />
<img alt="" src="images/xortexturedark.gif" style=
"width: 64px; height: 64px;" /> <img alt="" src=
"images/xortexturebright.gif" style=
"width: 64px; height: 64px;" /><br />
<br />
<b>3)</b> On the other hand, if the size is larger than 256, for
example 512, you have to make sure the color is limited to a
maximum value of 256. You can either modulo divide it through 256,
but then it isn't a real XOR pattern anymore. Better is to divide
it through 2. In any case, using a XOR texture larger than 256x256
doesn't increase the quality because there aren't enough distinct
color values, unless you're using a color mode that allows more
bits per channel. But who'd want to generate a 1024x1024 XOR
texture anyway.<br />
<br />
The XOR operator takes the binary values of both integers, and does
a binary XOR on every two corresponding bits. XOR or eXclusive OR
returns 1 if both bits are different, and returns 0 if both bits
are the same: "Bit a is 1 OR bit 2 is 1, but <i>not</i> both". In
other words, it applies the following truth table to every two
corresponding bits:<br />
<br />
<table style="width: 400px; text-align: left;" border="1"
cellpadding="1" cellspacing="0">

<tr align="center">
<td colspan="3" rowspan="1" style="vertical-align: top;">
<b>XOR</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><i>Bit_a</i><br /></td>
<td style="vertical-align: top;"><i>Bit_b</i><br /></td>
<td style="vertical-align: top;"><i>Result</i><br /></td>
</tr>
<tr>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
</tr>
<tr>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;">0<br /></td>
</tr>

</table>
<br />
This is done on every bit of the integer, creating the many
possible resulting values.<br />
<br />
For example, 5 XOR 13 = 8, because in binary 0101 XOR 1101 =
1000.<br />
<br />
<h2><a name="Colors" id="Colors"></a>Colors</h2>
You can also try the XOR texture with different colors, by using
different value for R, G and B. For example:<br />
<br />
<center>
<table class="codetable">
<tr>
<td style="vertical-align: top;">
<pre><span class="code">int main(int argc, char *argv[])
{
    screen(256, 256, 0, <span class=
"string">"The XOR Texture"</span>);
  
    ColorRGB color;
    
    for(int x = 0; x &lt; w; x++)
    for(int y = 0; y &lt; h; y++)
    {   
         Uint8 c = (x ^ y);
         color.r = 255 - c;
         color.g = c;
         color.b = c % 128;
         pset(x, y, color);
    }
      
    redraw();
    sleep();
    return 0;
}
</span></pre>
</td>
</tr>
</table>
</center>
<br />
<img alt="" src="images/xortexturecolor.gif" style=
"width: 256px; height: 255px;" /><br />
<br />
You can even use the xor value as hue for the HSVtoRGB
function...<br />
<br />
<center>
<table class="codetable">
<tr>
<td style="vertical-align: top;">
<pre><span class="code">int main(int argc, char *argv[])
{
    screen(256, 256, 0, <span class=
"string">"The XOR Texture"</span>);
  
    ColorRGB color; 
      
    for(int x = 0; x &lt; w; x++)
    for(int y = 0; y &lt; h; y++)
    {   
         Uint8 c = (x ^ y);
         color = HSVtoRGB(ColorHSV(c, 255, 255));
         pset(x, y, color);
    }
  
    redraw();
    sleep();
    return 0;
}
</span></pre>
</td>
</tr>
</table>
</center>
<br />
<img alt="" src="images/xortexturehsv.gif" style=
"width: 256px; height: 256px;" /><br />
<br />
<h2><a name="AND_and_OR" id="AND_and_OR"></a>AND and OR</h2>
The AND and the OR operator also generate a similar texture.<br />
<br />
The XOR operator returns 1 if both bits are different:<br />
<br />
<table style="width: 400px; text-align: left;" border="1"
cellpadding="1" cellspacing="0">

<tr align="center">
<td colspan="3" rowspan="1" style="vertical-align: top;">
<b>XOR</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><i>Bit_a</i><br /></td>
<td style="vertical-align: top;"><i>Bit_b</i><br /></td>
<td style="vertical-align: top;"><i>Result</i><br /></td>
</tr>
<tr>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
</tr>
<tr>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;">0<br /></td>
</tr>

</table>
<br />
The AND operator, only returns 1 if both bits are 1 (bit a AND bit
b are true)<br />
<br />
<table style="width: 400px; text-align: left;" border="1"
cellpadding="1" cellspacing="0">

<tr align="center">
<td colspan="3" rowspan="1" style="vertical-align: top;">
<b>AND</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><i>Bit_a</i><br /></td>
<td style="vertical-align: top;"><i>Bit_b</i><br /></td>
<td style="vertical-align: top;"><i>Result</i><br /></td>
</tr>
<tr>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
</tr>
<tr>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;">0<br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
</tr>

</table>
<br />
The OR operator returns 1 if any or both of the bits are 1 (bit a
OR bit b is true)<br />
<br />
<table style="width: 400px; text-align: left;" border="1"
cellpadding="1" cellspacing="0">

<tr align="center">
<td colspan="3" rowspan="1" style="vertical-align: top;">
<b>OR</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><i>Bit_a</i><br /></td>
<td style="vertical-align: top;"><i>Bit_b</i><br /></td>
<td style="vertical-align: top;"><i>Result</i><br /></td>
</tr>
<tr>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;">0<br /></td>
</tr>
<tr>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;">0<br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
</tr>
<tr>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
<td style="vertical-align: top;"><b>1</b><br /></td>
</tr>

</table>
<br />
The AND operator is denoted '&amp;' in C++, and the OR operator
'|', replace the '^' operator with those to use the new operators.
Here's the result of XOR, AND and OR respectively:<br />
<br />
<img alt="" src="images/xortexture.gif" style=
"width: 255px; height: 255px;" /> <img alt="" src=
"images/andtexture.gif" style="width: 255px; height: 255px;" />
<img alt="" src="images/ortexture.gif" style=
"width: 254px; height: 255px;" /><br />
<br />
It makes sense that the AND texture is darker, because it returns 1
only in a single case. The OR texture is brighter, because it
returns 1 very often. The sum of the XOR texture and the AND
texture is the OR texture.<br />
<h2><a name="Conclusion" id="Conclusion"></a>Conclusion</h2>
It was shown how easy it is to create a XOR texture, which makes
the XOR texture useful to test if a texture renderer is working.
However, it's not suitable for applications such as art or
games.<br />
<br />
Here, the XOR pattern was used as a 3D texture (x ^ y ^ z) to test
if a planet texture renderer was working correctly:<br />
<br />
<img alt="" src="images/xorplanet.gif" style=
"width: 320px; height: 240px;" /><br />
<br />
<hr />
Last edited: 2004
<br /><br />
Copyright (c) 2004-2007 by Lode Vandevenne. All rights reserved.
</body>
</html>
